C51 COMPILER V9.60.7.0   DS18B20                                                           12/25/2025 11:33:45 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE DS18B20
OBJECT MODULE PLACED IN .\Objects\DS18B20.obj
COMPILER INVOKED BY: C:\Users\Alex\AppData\Local\Keil5\C51\BIN\C51.EXE Drivers\DS18B20.c OPTIMIZE(8,SPEED) BROWSE INCDIR
                    -(.\Drivers) DEBUG OBJECTEXTEND PRINT(.\Listings\DS18B20.lst) TABS(2) OBJECT(.\Objects\DS18B20.obj)

line level    source

   1          /**
   2           * @file DS18B20.c
   3           * @brief DS18B20 温度传感器驱动
   4           */
   5          
   6          #include "DS18B20.h"
   7          
   8          void ds1820rst(void) {
   9   1        TR0 = 0;        // 禁用定时器
  10   1        DQ = 1;         // 拉高总线
  11   1        delay_us(4);    // 延时4μs
  12   1        DQ = 0;         // 拉低总线，开始复位脉冲
  13   1        delay_us(100);  // 保持拉低
  14   1        DQ = 1;         // 释放总线
  15   1        delay_us(40);   // 等待脉冲
  16   1        TR0 = 1;        // 重新启用定时器
  17   1      }
  18          
  19          uint8_t ds1820rd(void) {
  20   1        uint8_t i, dat = 0;
  21   1        TR0 = 0;
  22   1      
  23   1        for (i = 0; i < 8; i++) {
  24   2          DQ = 0;  // 拉低总线
  25   2          dat >>= 1;
  26   2          DQ = 1;         // 释放总线
  27   2          if (DQ)         // 读取总线状态
  28   2            dat |= 0x80;  // 如果为高电平，将MSB设为1
  29   2          delay_us(10);   // 等待时隙结束
  30   2        }
  31   1      
  32   1        TR0 = 1;
  33   1        return dat;
  34   1      }
  35          
  36          void ds1820wr(uint8_t wdata) {
  37   1        uint8_t i;
  38   1        TR0 = 0;
  39   1      
  40   1        for (i = 0; i < 8; i++) {
  41   2          DQ = 0;
  42   2          DQ = wdata & 0x01;
  43   2          delay_us(10);
  44   2          DQ = 1;
  45   2          wdata >>= 1;
  46   2        }
  47   1      
  48   1        TR0 = 1;
  49   1      }
  50          
  51          int16_t get_temper(uint8_t* rom_id) {
  52   1        uint8_t a, b;     // 存储温度数据的高低字节
  53   1        uint16_t tvalue;  // 合并后的温度原始值
  54   1        int16_t itemp;    // 最终返回的温度值
C51 COMPILER V9.60.7.0   DS18B20                                                           12/25/2025 11:33:45 PAGE 2   

  55   1        int32_t temp_calc;
  56   1        uint8_t i, j;
  57   1      
  58   1        // 启动温度转换
  59   1        ds1820rst();               // 复位
  60   1        ds1820wr(0x55);            // 匹配ROM
  61   1        for (i = 0; i < 8; i++) {  // 发送8字节ROM ID
  62   2          ds1820wr(rom_id[i]);
  63   2        }
  64   1        ds1820wr(0x44);
  65   1      
  66   1        // 读取温度数据
  67   1        ds1820rst();               // 复位
  68   1        ds1820wr(0x55);            // 匹配ROM
  69   1        for (j = 0; j < 8; j++) {  // 发送8字节ROM ID
  70   2          ds1820wr(rom_id[j]);
  71   2        }
  72   1        ds1820wr(0xBE);
  73   1      
  74   1        a = ds1820rd();
  75   1        b = ds1820rd();
  76   1        tvalue = ((uint16_t)b << 8) | a;  // 合并高低字节
  77   1      
  78   1        // 转换为0.1℃精度：原始值 × 0.0625 × 10 = 原始值 × 625 ÷ 1000
  79   1        temp_calc = (int16_t)tvalue;
  80   1        temp_calc = temp_calc * 625;
  81   1      
  82   1        // 四舍五入
  83   1        if (temp_calc >= 0) {
  84   2          itemp = (int16_t)((temp_calc + 500) / 1000);
  85   2        } else {
  86   2          itemp = (int16_t)((temp_calc - 500) / 1000);
  87   2        }
  88   1      
  89   1        return itemp;
  90   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    312    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
